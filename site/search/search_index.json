{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#installing-the-plugin","title":"Installing the Plugin","text":"<ul> <li>IntelliJ IDEA --&gt; Preferences --&gt; Plugins --&gt; Marketplace</li> <li>Search for Unlogged in the marketplace &amp; Install</li> </ul>"},{"location":"#adding-the-dependency","title":"Adding the dependency","text":"mavengradle <pre><code>&lt;dependency&gt;\n&lt;artifactId&gt;unlogged-sdk&lt;/artifactId&gt;\n&lt;groupId&gt;video.bug&lt;/groupId&gt;\n&lt;version&gt;0.1.14&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>dependencies\n{\nimplementation 'video.bug:unlogged-sdk:0.1.14'\nannotationProcessor 'video.bug:unlogged-sdk:0.1.14'\n}\n</code></pre> <p>Sync your project once so that the Unlogged dependency is downloaded from maven repository.</p>"},{"location":"#adding-the-annotion","title":"Adding the annotion","text":"<p>To start recording method input and return values - add <code>@Unlogged</code> annoation just above your main method.</p> <p>Here is an example.</p> <pre><code>   @Unlogged\npublic static void main(String[] args) {\nSpringApplication.run(JwtDemoApplication.class, args);\n}\n</code></pre>"},{"location":"#clean-and-debug","title":"Clean, and Debug!","text":"mavengradle <pre><code>mvn clean\n</code></pre> <pre><code>gradle clean\n</code></pre> <p>Start your application in debug mode to call any java function directly.</p>"},{"location":"commonerrors/","title":"Common Errors","text":""},{"location":"commonerrors/#errors-with-direct-invoke","title":"Errors with Direct Invoke","text":"<p>--Explain shortly how Direct invoke works--</p> <p>--List down all the errors related to direct invoke.</p>"},{"location":"commonerrors/#errors-with-logging","title":"Errors with Logging","text":"<p>unlogged-sdk logs code execution and unlogged-plugin scans these logs and creates test candidates. </p> <p>Failed to serialize response object</p> <p>There are a few fields we can't serialize. You will see the error:  <code>Failed to serialize response object of type</code> This means that the object, Pojo or an extended object can not be serialized. </p> <p>Here is a list of Pojos/Objects that can't be serialized:</p>"},{"location":"coverage/","title":"Code Coverage","text":"<p>Getting code coverage number above 90% is often challenging and takes a lot of time and effort. </p> <p>Unlogged highlights the lines of code executed and offers you the feedback on code coverage. </p> <p></p> <p>The code coverage won't increase unless you save the candidates with assertions. </p> <p>Note the potential uptick  in the coverage number on the replay window.</p>"},{"location":"coverage/#tracking","title":"Tracking","text":"<p>You can check the progress in the tab <code>Code Coverage</code> every time you save different candidates.</p> <p>Track class coverage, method coverage and line coverage in this tab.</p> <p></p> <p>Tip</p> <p>The code coverage is shown even when you use external tools such as Postman, or Swagger to execute a method through an http end point.</p>"},{"location":"curiosity/","title":"How does this all work?","text":"<p>unlogged-sdk logs code execution and unlogged-plugin scans these logs and creates test candidates. </p>"},{"location":"curiosity/#unlogged-sdk","title":"Unlogged SDK","text":"<p>unlogged-sdk adds logging probes to the <code>java</code> code in compile time.</p> <p>We have extended lombok's implementation to add such probes automatically. </p> <p>Check our blog post that explains how lombok works </p>"},{"location":"curiosity/#unlogged-plugin","title":"Unlogged Plugin","text":""},{"location":"curiosity/#direct-invoke","title":"Direct Invoke","text":""},{"location":"curiosity/#scanning-logs","title":"Scanning Logs","text":""},{"location":"curiosity/#extracting-candidates","title":"Extracting Candidates","text":""},{"location":"curiosity/#mocking","title":"Mocking","text":""},{"location":"directinvoke/","title":"Call Java Methods Directly","text":"<p>To test a <code>java</code> method, you either have to write a unit test, or expose an http end point and then <code>F8</code>/step over  till you reach your method. A few folks often use <code>System.out.print</code> to debug. </p> <p>We connect a lot with this meme from monkeyuser</p> <p> </p>"},{"location":"directinvoke/#direct-invoke","title":"Direct Invoke","text":"<p>With <code>Direct Invoke</code> you can call a Java method directly. Once you start your application in debug mode, you will see the cyan colored icon next to any method. Click on it and Unlogged pre-fills it with dummy arguments. Execute the method and you will get the return value just for the method you called.</p> <p></p>"},{"location":"directinvoke/#debug-where-it-matters","title":"Debug where it matters","text":"<p>Start debugging where it matters. Put a breakpoint anywhere in the method and execute a method using <code>Direct Invoke</code>. Check IntelliJ's debugger and values of all variables.</p> <p>No need to expose an http end point or write a unit test to debug something deep within your code.</p> <p>Warning</p> <p>DO NOT call your <code>main</code> method using <code>Direct Invoke</code> It will fail since it attempts to start the process again using Unlogged with the same ports.</p>"},{"location":"gutter/","title":"Gutter Icon States","text":"<p>Once you install Unlogged, for each method in your code base, you will see different gutter icons. The code, record, replay lifecycle revolves around these 6 gutter icons. </p> <p>Here are different gutter icons and what they mean</p> <p>Application Not Running with Unlogged</p> <p>This icon means that your application is not running with Unlogged. You can add the Unlogged dependency in your pom.xml or build.gradle, mvn clean or gradle clean and start debugging your application.</p> <p>Check Getting Started section to know how to add the dependency.</p> <p>Application Running with Unlogged</p> <p>Once you see this icon, it means that your application is running with Unlogged. Now, you can invoke any method inside your Java code using Direct Invoke or call http end points using Postman, Swagger or UI.</p> <p>Use Postman, Swagger in case you are accessing these methods through http end points. You can even use your UI to send data to your application. </p> <p>You can use <code>Direct Invoke</code> inside the plugin to call any Java method directly. This will save you a lot of time in debugging deep within your code. You can start debugging your methods right where it matters.</p> <p>Recording Available for methods</p> <p>Once you execute a method, using either Direct Invoke, Postman, or Swagger, you will see this icon. It indicates that Unlogged has recorded input and return values for the method. </p> <p>Click on the icon and you can check the recorded data</p> <p></p> <p>Execute Method</p> <p>If you make code changes after a recording is done for a method, you will see a bolt icon. That means you can now hot-relaod the code changes within this method and replay its previously recorded inputs.</p> <p>Note the code changes in getWeatherinfo in the above vs below code snippet.</p> <p></p> <p>Passing Case</p> <p>After your code changes, and once you execute the method, this icon tells you if the return value is same as before. </p> <p></p> <p>Failing Case</p> <p>After your code changes, and once you execute the method, this icon tells you if the return value is different from before. </p> <p></p> <p>Here is a cheat sheet that explains these gutter states in short.</p> <p></p>"},{"location":"mocking/","title":"Mocking","text":"<p>With one click, Unlogged lets you mock API, DB, downstream service calls </p> <p>and file operations.</p>"},{"location":"mocking/#using-recorded-data","title":"Using Recorded Data","text":"<p>Unlogged automatically identifies the lines of code that can be mocked. </p> <p> A ghost icon will appear next to the identified lines. </p> <p>Click on the ghost icon, and define the <code>when</code> condition and the corresponding<code>then</code> return value, and click save. This will change the code in runtime and replace this line of code with the mock you just defined.</p> <p></p>"},{"location":"mocking/#mock-as-you-write","title":"Mock as you write!","text":"<p>When you write a line of code, we automatically detect if the logic in the line can be mocked. </p> <p>You can click on the icon and define the mock, manually.</p>"},{"location":"mocking/#permanent-mocks","title":"Permanent Mocks","text":"<p>If you want to test only your application using APIs or UI, you can enable the permanent mocks. With this check, even when your method is accessed using an API call, the permanently mocked line will be mocked.</p> <p>This is helpful while testing your method outside of <code>Direct Invoke</code>, using Postman, or Swagger or your application UI.</p> <p></p>"},{"location":"saving/","title":"Saving Candidates","text":""},{"location":"saving/#whats-a-candidate","title":"What's a Candidate?","text":"<p>When you execute a method using <code>Direct Invoke</code> or through an http endpoint, you will see the method input values that can be replayed. </p> <p>Each unique combination of input and return value is called a Candidate.</p> <p>Tip</p> <p>By default, when you replay a candidate, Unlogged compares the return value object down to the key level. </p> <p>But return value may contain ever changing or irrelevant fields such as timestamp. That's where Assertions come in picture.</p>"},{"location":"saving/#creating-assertions","title":"Creating Assertions","text":"<p>When you click on Save Replay - you will see a window that presents the recorded value of the object for the candidate we just replayed.  </p> <p></p>"},{"location":"saving/#defining-assertions","title":"Defining Assertions","text":"<p>You can define any assertion on this return value, down to any key/value pair. You can define nested assertions with <code>AND</code> <code>OR</code> <code>NOT</code> on different key-value pairs and group them together. </p>"},{"location":"saving/#list-of-operators","title":"List of Operators","text":"<p>Here are the operators, what they do and how it is evaluated on a data type. Also, how a passing and a failing case looks like.</p> Operator Description for Assertions  Passing Case  Failing Case is Asserts that a value is as expected. <code>assertThat(value).is(expected);</code> <code>assertThat(value).is(unexpected);</code> size is Asserts the size of a collection or array. <code>assertThat(list).sizeIs(10);</code> <code>assertThat(list).sizeIs(5);</code> length is Asserts the length of a string. <code>assertThat(string).lengthIs(5);</code> <code>assertThat(string).lengthIs(7);</code> equals ignore case Asserts string equality, ignoring case. <code>assertThat(str1).equalsIgnoreCase(str2);</code> <code>assertThat(str1).equalsIgnoreCase(\"Different\");</code> is not Asserts that a value is not as expected. <code>assertThat(value).isNot(unexpected);</code> <code>assertThat(value).isNot(expected);</code> size is not Asserts the size is not a specific value. <code>assertThat(list).sizeIsNot(5);</code> <code>assertThat(list).sizeIsNot(10);</code> length is not Asserts the length is not a specific value. <code>assertThat(string).lengthIsNot(7);</code> <code>assertThat(string).lengthIsNot(5);</code> is false Asserts that a boolean value is false. <code>assertThat(booleanValue).isFalse();</code> <code>assertThat(trueValue).isFalse();</code> matches regex Asserts that a string matches a regex. <code>assertThat(str).matchesRegex(\"regexPattern\");</code> <code>assertThat(str).matchesRegex(\"wrongPattern\");</code> not matches regex Asserts that a string doesn't match regex. <code>assertThat(str).doesNotMatchRegex(\"wrongPattern\");</code> <code>assertThat(str).doesNotMatchRegex(\"regexPattern\");</code> is true Asserts that a boolean value is true. <code>assertThat(booleanValue).isTrue();</code> <code>assertThat(falseValue).isTrue();</code> &lt; Asserts that a value is less than expected. <code>assertThat(number).isLessThan(10);</code> <code>assertThat(number).isLessThan(5);</code> &lt;= Asserts that a value is less or equal. <code>assertThat(number).isLessOrEqualTo(5);</code> <code>assertThat(number).isLessOrEqualTo(4);</code> &gt; Asserts that a value is greater than expected. <code>assertThat(number).isGreaterThan(20);</code> <code>assertThat(number).isGreaterThan(25);</code> &gt;= Asserts that a value is greater or equal. <code>assertThat(number).isGreaterOrEqualTo(15);</code> <code>assertThat(number).isGreaterOrEqualTo(16);</code> is not null Asserts that a value is not null. <code>assertThat(value).isNotNull();</code> <code>assertThat(nullValue).isNotNull();</code> is null Asserts that a value is null. <code>assertThat(nullValue).isNull();</code> <code>assertThat(value).isNull();</code> is empty Asserts that a value is empty. <code>assertThat(\"\").isEmpty();</code> <code>assertThat(\"text\").isEmpty();</code> is not empty Asserts that a value is not empty. <code>assertThat(\"text\").isNotEmpty();</code> <code>assertThat(\"\").isNotEmpty();</code> contains key in object Asserts the presence of a key in an object. <code>assertThat(map).containsKey(\"key\");</code> <code>assertThat(map).containsKey(\"missing\");</code> contains item in array Asserts the presence of an item in an array. <code>assertThat(array).containsItem(item);</code> <code>assertThat(array).containsItem(\"notFound\");</code> not contains item in array Asserts the absence of an item in an array. <code>assertThat(array).doesNotContainItem(\"notFound\");</code> <code>assertThat(array).doesNotContainItem(item);</code> contains substring Asserts the presence of a substring in a string. <code>assertThat(string).containsSubstring(\"substring\");</code> <code>assertThat(string).containsSubstring(\"missing\");</code> not contains key in object Asserts the absence of a key in an object. <code>assertThat(map).doesNotContainKey(\"missing\");</code> <code>assertThat(map).doesNotContainKey(\"key\");</code> not contains substring Asserts the absence of a substring in a string. <code>assertThat(string).doesNotContainSubstring(\"missing\");</code> <code>assertThat(string).doesNotContainSubstring(\"substring\");</code> <p></p> <p>Tip</p> <p>Green background color means a passing assertion and red means a failing assertion. </p>"},{"location":"saving/#saving-the-replays","title":"Saving the Replays","text":"<p>Replays with assertions are saved at the below location</p> <p><code>/YOUR MODULE DIRECTORY/src/test/resources/unlogged</code></p> <p></p> <p>Replaying with Assertions</p> <p>For your code change, when you replay the candidate, Unlogged will execute the assertion you just saved and inform if the candidate passes or fails the assertions.</p>"},{"location":"saving/#collaborate","title":"Collaborate","text":"<p>You can now push these replays to your git repository, so that your team members can pull and replay locally for their code changes.</p>"}]}